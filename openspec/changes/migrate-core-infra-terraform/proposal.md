# Change: Migrate Core Infrastructure to Terraform

## Why

The current bash-based Azure CLI approach for infrastructure provisioning has grown complex with:
- Manual spot retry logic and VM failure recovery in bash
- No drift detection or state locking mechanisms
- Difficult to extend for multi-cloud (AWS support exists but uses similar imperative patterns)
- Infrastructure facts mixed with runtime state in deployment-state.yaml
- VM size validation and zone selection embedded in scripts

Terraform provides declarative infrastructure-as-code with proven state management, drift detection, and multi-cloud support through a consistent provider model.

## What Changes

Create Terraform modules for core infrastructure that replace bash scripts:

**Azure Infrastructure (replaces bin/setup-azure-network.sh, bin/create-azure-vms.sh)**:
- Resource group, VNet, subnet, NSG with security rules
- SSH key management (Azure SSH Key resource)
- Controller and worker VMs with cloud-init, zone placement, spot/regular priority
- Output: VM IPs, resource names, WireGuard port for downstream scripts

**AWS Infrastructure (NEW - future extensibility)**:
- VPC, subnets, security groups, internet gateway
- EC2 key pairs
- Controller and worker EC2 instances with user-data, availability zone placement
- Output: Instance IPs, resource identifiers for downstream scripts

**Module Structure**:
```
terraform/
├── modules/
│   ├── azure/
│   │   ├── network/          # RG, VNet, NSG
│   │   ├── compute/          # VMs with cloud-init
│   │   └── outputs.tf
│   └── aws/
│       ├── network/          # VPC, subnets, security groups
│       ├── compute/          # EC2 instances
│       └── outputs.tf
├── environments/
│   └── (tfvars files generated from k0rdent.yaml)
└── main.tf                   # Root module with provider selection
```

**Integration Points**:
- New script `bin/terraform-wrapper.sh` to invoke Terraform with config from k0rdent.yaml
- Existing bash scripts (prepare-deployment.sh, manage-vpn.sh, install-*.sh) consume Terraform outputs
- Cloud-init/user-data files still generated by prepare-deployment.sh (fed as input to Terraform)
- State management functions updated to read from Terraform state for infrastructure facts

## Impact

- **BREAKING**: Changes deployment workflow to require `terraform init/apply` before bash orchestration
- **Affected code**:
  - `bin/setup-azure-network.sh` - logic moves to terraform/modules/azure/network
  - `bin/create-azure-vms.sh` - logic moves to terraform/modules/azure/compute
  - `etc/state-management.sh` - adds terraform state reading functions
  - `deploy-k0rdent.sh` - updated to call terraform-wrapper.sh first
  - `bin/configure.sh` - extended to generate tfvars from YAML config
- **Affected specs**: Creates new capabilities `azure-infrastructure`, `terraform-modules`
- **Migration path**: Provide `--legacy` flag to maintain bash-only path during transition
- **AWS support**: Framework ready for AWS modules, maintaining parity with Azure structure

## Benefits

- **State management**: Remote state with locking (Azure Storage, S3, Terraform Cloud)
- **Drift detection**: `terraform plan` shows infrastructure changes outside Terraform
- **Multi-cloud**: Consistent patterns for Azure and AWS
- **Reusability**: Modules can be composed for different deployment scenarios
- **Validation**: Terraform validates VM sizes, regions, zones at plan time
- **Atomic operations**: Infrastructure changes are applied atomically with rollback support

## Risks & Mitigations

- **Secrets in state**: WireGuard keys and SSH private keys stay in bash workflow; only public keys/references in Terraform
- **Learning curve**: Provide clear examples and Makefile/wrapper for common operations
- **State corruption**: Use remote state with locking from day one; document state recovery procedures
- **Transition complexity**: Keep bash path working with `--legacy` flag; gradual migration per environment
